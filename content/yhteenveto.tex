\chapter{Yhteenveto}
Staattinen tyypitys jakaa mielipiteitä. Facebook on kehittänyt
staattiset tyyppijärjestelmät myös \textit{Pythonin} (1990) ja \textit{PHP:n} (1995)
analysointiin \cite{PyreCheck, HackLang}.
Dynaamisesti tyypitetyn \textit{Clojuren} (2007) kehittäjä
Rich Hickey on puolestaan kritisoinut staattista
tyypitystä useaan otteeseen \cite{10YearsOfClojure}. Eksplisiittiset
tyyppimäärittelyt vaativat lisää kirjoitettavaa koodia ja liian tiukka
tyyppijärjestelmä voi rajoittaa sitä mitä kielellä voi tehdä, sillä harva
tyyppijärjestelmä on täydellinen (engl. complete). JavaScriptissä on useita
yleisesti käytettyjä rajapintoja jotka ovat hyödyllisiä mutta vaikeita
tyypittää staattisesti. Esimerkiksi suositusta kirjastosta \textit{lodash}
löytyy funktio \inlinecode{get} \cite{LodashGet}, jota voidaan kutsua
seuraavasti

\begin{lstlisting}[caption={
	get-funktiolla voidaan palauttaa arvo syvältä
	objektin sisältä välittämättä mahdollisesti puuttuvista arvoista.},
  label={fig:lodash_get_function},
  aboveskip={20pt}
]
	import {get} from 'lodash';

	const object = { a: [{ b: { c: 3 } }], d: null };
	get(object, 'a[0].b.c'); // Palauttaa numeron 3
\end{lstlisting}

Staattisen tyyppijärjestelmän on vaikea päätellä esimerkin get-kutsun
palautusarvo tai tarkistaa toisen argumentin oikeellisuus. Ohjelmoija joutuu
joko luopumaan tyyppiturvallisuudesta tässä
osassa koodia tai kirjoittamaan jonkin
huomattavasti monimutkaisemman version säilyttääkseen tyyppiturvallisuuden.

Dynaamisen koodin nopeasta kirjoitustahdista saatavat hyödyt jäävät kuitenkin
vähäisiksi jos lopputuotos ei toimi odotetulla tavalla. Bugit heikentävät
käyttäjien tyytyväisyyttä ohjelmaan ja voivat pahimmillaan aiheuttaa sellaista
vahinkoa että koko bugisen ohjelman julkaisusta saatu nettohyöty on negatiivinen,
eli sen käyttöönotto aiheuttaa enemmän haittaa kuin hyötyä. Staattinen tyypitys
ohjaa kirjoitettua koodia turvalliseen suuntaan kehitysvaiheen alusta
loppuun, ja torjuu tietynlaisia ohjelmointivirheitä tehokkaammin kuin
esimerkiksi ajonaikaista käyttäytymistä testaavat \textit{unit testit}.
Esimerkissä \ref{fig:lodash_get_function} esitelty get-kutsu on yksinkertainen
ja helppolukuinen, mutta jos muuttujan \inlinecode{object} tyyppiä myöhemmin
muutetaan toiseen muotoon muistamatta päivittää myös get-kutsua, virheellisestä
get-kutsusta voi muodostua ohjelmaan hankala bugi.

Flow, TypeScirpt ja Closure sallivat sekä dynaamisesti että
staattisesti tyypitetyn koodin käytön ja hämärtävät rajaa niiden välillä.
Jää ohjelmoijan päätettäväksi onko yllä mainitun get-kutsun yksinkertaisuus
tyyppiturvattomuuden arvoista. JavaScript-kehityksessä hyväksi todetut
suunnittelumallit ovat edelleen käytettävissä tyyppiannotoidussakin
koodissa, vaikka välillä tyyppiturvallisuutta olisikin sen vuoksi höllättävä.
Lopputulos ei ole ainakaan sen turvattomampaa kuin normaali JavaScript-koodikaan
ja tyyppiturvaton osa koodia voidaan usein rajata pieneksi, muilla tavoin
testatuksi osa-alueekseen muuten staattisesti tarkastetussa kokonaisuudessa.
Samankaltaisuus ja yhteensopivuus tavallisen JavaScriptin kanssa onkin
näiden työkalujen tärkein etu muihin staattisesti tyypitettyihin kieliin
nähden. JavaScript projektit on mahdollista muuttaa vaiheittain staattisesti
tyypitetyksi kirjoittamatta koko ohjelman koodia alusta asti uudestaan, eikä
ohjelmoijan itsensä tarvitse korvata kaikkea JavaScriptista oppimaansa
uuden kielen tavoilla ja yhteisöllä. Closuren JSDoc-tyyliset kommentit
saattavat jo ollakin JavaScript-ohjelmoijalle tuttuja, sillä niitä käytetään
usein koodin dokumentointiin vaikka tyyppien oikeellisuutta ei
tarkastettaisikaan Closurella. Myös TypeScirpt- ja Flow-annotaatiot voivat
helpottaa uusien JavaScript-ohjelmoijien tutustumista uuteen projektiin
tuomallaan dokumentaatioarvolla.

Samankaltaisuus ja yhteensopivuus jo ennestään suositun JavaScriptin kanssa
yhdistettynä tyyppiturvallisuuteen, koodin kirjoittamista helpottaviin
työkaluihin ja selkeämmin dokumentoituun koodiin ovat nostaneet erityisesti
TypeScirptin käytön nopeaan kasvuun. Vuosittaisessa JavaScript-yhteisölle
tarkoitetussa \textit{State Of JS} kyselytutkimuksessa 46.7\% vuonna 2018
vastanneista ilmoitti käyttäneensä TypeScriptiä ja haluavansa
käyttää sitä uudestaan \cite{StateOfJs2018}.
Vielä vuonna 2016 luku oli 21\% \cite{StateOfJs2016}. TypeScirpt ja
JavaScriptin staattinen tyypitys näyttävät kasvattavan suosiotaan myös
tulevaisuudessa. Vuoden 2018 State Of JS kyselyyn vastanneista 33.7\%
vastasi haluavansa\newline
opetella TypeScriptiä ja 34.5\% Flow'ta.
