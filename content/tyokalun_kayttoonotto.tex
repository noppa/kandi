\chapter{Työkalun käyttöönotto}

\section{Tyyppiannotaatiot}

Tyyppijärjestelmä voi päätellä muuttujan sallitun tyypin automaattisesti
päättelemällä tai kieleen sisältyvien eksplisiittisten tyyppimäärittelyjen
perusteella. SML kykenee tulkitsemaan kaikkien muuttujien arvot
automaattisesti, kun taas Java vaatii kaikkien olevan eksplisiittisesti
annotoituja. Suurin osa staattisesti tyyppitarkastetuista kielistä kuitenkin
putoaa jonnekkin välimaastoon. Haskell, C\#, Crystal ja monet muut tarjoavat
syntaksin tyyppien eksplisiittiselle määrittämiselle mutta tarjoavat myös
kielikohtaisesti vaihtelevan tuen tyyppien automaattiselle päättelylle. Tässä
on hyvä huomioida että vaikka tyyppien tulkinta tapahtuu automaattisesti,
niin se suoritetaan tässä tapauksessa silti käännös- eikä suoritusaikana.
Esimerkiksi yllä mainittu Crystal on tarvittavien annotaatioiden vähyydestä
huolimatta staattisesti tyyppitarkastettu, toisin kuin syntaksin inspiraation
lähteenä ollut Ruby.

Kaikki kolme tässä esiteltyä JavaScriptin staattiseen tyyppitarkastukseen
tarkoitettua työkalua päättelevät tyyppejä automaattisesti, mutta vaativat
myös eksplisiittisiä määrityksiä paikoitellen. Closure-kääntäjä lukee
tyyppimääritykset JSDoc-tyylisistä dokumentaatiokommenteista. TypeScript ja
Flow puolestaan jatkavat ECMA-262 -spesifikaatiota erityisellä syntaksilla
tyyppien eksplisiittistä määrittelyä varten. Kumpikaan näistä
lähestymistavoista ei ole täysin ongelmaton. Dokumentaatiokommentit voivat
olla hankala ja ”verbose” formaatti monimutkaisille tyyppiannotaatioille,
mikä kasvattaa niiden kirjoittamiseen vaadittua työmäärää. [Hejlsberg quote].
Toisaalta jo opitun JavaScriptin syntaksin jatkaminen uudella syntaksilla
vaatii uusien merkintöjen oppimmista ja saattaa vaikeuttaa kirjoitetun koodin
lukemista etenkin tottumattomille lukijoille.

\section{Ohjelman kääntäminen ennen suorittamista}

JavaScript koodi tulkataan tai käännetään tyypillisesti suorittamisen
yhteydessä, selaimesta tai muusta suoritusympäristöstä löytyvän ”moottorin”
toimesta. EcmaScript standardin mukaista koodia suorittamaan suunnitellut
moottorit, kuten V8 tai SpiderMonkey, eivät kuitenkaan osaa käsitellä
TypeScript- tai Flow-annotaatioilla merkattua koodia. Näinollen TypeScript-
tai Flow-annotoitu koodi on välttämätöntä [sivuhuomio] kääntää muotoon jossa
annotaatiot on poistettu ja jäljellä on enää standardinmukainen JavaScript.
Koska JavaScriptin käyttäminen ei normaalisti vaadi erillistä
käännösvaihetta, useissa projekteissa ei ole sellaista käytetty. Koodin
minimointi ja muu optimointi on ollut parhaiden käytäntöjen mukaista jo
tovin, mutta tällaiset koodinkäsittelyt tehdään yleensä vasta ennen koodin
julkaisua. Kehittäjät ovat tavanomaisesti voineet suorittaa kirjoittamansa
JavaScriptin sellaisenaan kehitysympäristössä. Käännösvaiheen aikavaatimus
pyritään luonnollisesti pitämään mahdollisimman pienenä, mutta se on silti
projektin monimutkaisuuteen ja kehitysnopeuteen vaikuttava tekijä joka
työkalun käyttöönotossa tulee huomioida.