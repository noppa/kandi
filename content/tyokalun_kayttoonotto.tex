\chapter{Työkalun käyttöönotto}

\section{Tyyppiannotaatiot}

Tyyppijärjestelmä voi päätellä muuttujan sallitun tyypin automaattisesti
päättelemällä tai kieleen sisältyvien eksplisiittisten tyyppimäärittelyjen
perusteella. Esimerkiksi Standard ML kykenee tulkitsemaan kaikkien muuttujien
arvot automaattisesti, kun taas Java vaatii niiden olevan eksplisiittisesti
annotoituja. Suurin osa staattisesti tyyppitarkastetuista kielistä kuitenkin
putoaa jonnekkin välimaastoon. Haskell, C\#, Crystal ja monet muut sisältävät
syntaksin tyyppien eksplisiittiselle määrittämiselle mutta tarjoavat myös
kielikohtaisesti vaihtelevan tuen tyyppien automaattiselle päättelylle.
On hyvä huomioida että vaikka tyyppien tulkinta tapahtuu automaattisesti,
niin se suoritetaan tässä tapauksessa silti käännös- eikä suoritusaikana.
Esimerkiksi yllä mainittu Crystal on tarvittavien annotaatioiden vähyydestä
huolimatta staattisesti tyyppitarkastettu, toisin kuin syntaksin inspiraation
lähteenä ollut Ruby.

Kaikki kolme tässä esiteltyä JavaScriptin staattiseen tyyppitarkastukseen
tarkoitettua työkalua päättelevät tyyppejä automaattisesti, mutta vaativat
myös eksplisiittisiä määrityksiä paikoitellen. Closure-kääntäjä lukee
tyyppimääritykset JSDoc-tyylisistä dokumentaatiokommenteista \cite{annotatingJSforClosure}.
TypeScript ja Flow puolestaan jatkavat ECMA-262 -spesifikaatiota erityisellä syntaksilla
tyyppien eksplisiittistä määrittelyä varten. Kumpikaan näistä
lähestymistavoista ei ole täysin ongelmaton. Dokumentaatiokommentit voivat
olla hankala ja ”verbose” formaatti monimutkaisille tyyppiannotaatioille,
mikä kasvattaa niiden kirjoittamiseen vaadittua työmäärää. [Hejlsberg quote].
Toisaalta jo opitun JavaScriptin syntaksin jatkaminen uudella syntaksilla
vaatii uusien merkintöjen oppimmista ja saattaa vaikeuttaa kirjoitetun koodin
lukemista etenkin tottumattomille lukijoille.

\section{Ohjelman kääntäminen ennen suorittamista}

JavaScript koodi tulkataan tai käännetään tyypillisesti suorittamisen
yhteydessä, selaimesta tai muusta suoritusympäristöstä löytyvän ”moottorin”
toimesta. EcmaScript standardin mukaista koodia suorittamaan suunnitellut
moottorit, kuten V8 tai SpiderMonkey, eivät kuitenkaan osaa käsitellä
TypeScript- tai Flow-annotaatioilla merkattua koodia. Näinollen TypeScript-
tai Flow-annotoitu koodi on välttämätöntä [sivuhuomio] kääntää muotoon jossa
annotaatiot on poistettu ja jäljellä on enää standardinmukainen JavaScript.
Koska JavaScriptin käyttäminen ei normaalisti vaadi erillistä
käännösvaihetta, useissa projekteissa ei ole sellaista käytetty. Koodin
minimointi ja muu optimointi on ollut parhaiden käytäntöjen mukaista jo
tovin, mutta tällaiset koodinkäsittelyt tehdään yleensä vasta ennen koodin
julkaisua. Kehittäjät ovat tavanomaisesti voineet suorittaa kirjoittamansa
JavaScriptin sellaisenaan kehitysympäristössä. Käännösvaiheen aikavaatimus
pyritään luonnollisesti pitämään mahdollisimman pienenä, mutta se on silti
projektin monimutkaisuuteen ja kehitysnopeuteen vaikuttava tekijä joka
työkalun käyttöönotossa tulee huomioida.

\section{Työkalun vaiheittainen käyttöönotto}

Kun kyseessä on jo olemassa olevan kielen, JavaScriptin, muuttaminen
staattisesti tyyppitarkastetuksi, eräs merkittävä tekijä on että suuria
määriä koodia voidaan jo olla kehitetty alkuperäisellä kielellä ilman
tyyppitarkastuksista huolehtimista. Näin ollen tärkeäksi tekijäksi nousee
vaiheittainen käyttöönotto. On tärkeää että olemassa olevaa annotoimatonta
koodipohjaa voi yhä käyttää uuden, staattisesti tyyppitarkastetun koodin
kanssa. Flow-tarkastukset lisätään olemassa olevaan JavaScript-koodiin
erityisellä kommentilla. JavaScriptin muuttamisessa TypeScriptiksi riittää
yleensä tiedostopäätteen muuttaminen. Closure toimii ilman erillistä
muunnosta, kunhan tarvittava määrä dokumentaatiopohjaisia tyyppimäärittelyitä
on annettu. Sekä Flow että TypeScript tarjoavat myös erityisen tyypin ”any”
joka on kaikkien muiden tyyppien ylä- ja alatyyppi.