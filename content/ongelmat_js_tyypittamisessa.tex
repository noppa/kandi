\chapter{Ongelmat JavaScriptin staattisessa tyypittämisessä}

\section{EcmaScript-yhteensopivuus}
TypeScript pyrkii noudattamaan EcmaScript-spesifikaatiota mahdollisimman
tarkasti kaikkien sellaisten ominaisuuksien suhteen jotka eivät nimenomaan
liity staattiseen tyypittämiseen \cite{TypeScript_DesignGoals}. TypeScriptin
kehityksen alkuvaiheissa, ennen EcmaScript 2015-spesifikaation valmistumista,
JavaScriptista kuitenkin puuttui joitain tärkeiksi katsottuja ominaisuuksia,
jotka päätettiin lisätätä TypeScriptiin mahdollisista yhteensopimusongelmista
huolimatta. TypeScriptissä on esimerkiksi syntaksi nimiavaruuden määrittämiseen,
vaikka EcmaScriptiin myöhemmin lisätyt \textit{moduulit} ajavat saman asian
\cite{TypeScript_issuecomment_esnextfeatures}. TypeScript tukee nykyään sekä
alkuperäistä nimiavaruus-ominaisuuttaan että EcmaScriptin moduuleita.

Flow ja Closure-kääntäjä lisäävät koodiin ainoastaan staattista tyypitystä
koskevia ominaisuuksia, kuten tyyppimäärittelyjä, joten niissä ei ole
nimiavaruuksien kaltaisia koodin suoritukseen vaikuttavia ominaisuuksia.
EcmaScript kuitenkin kehittyy nopeasti ja sen päälle rakentavien työkalujen
on pysyttävä tahdissa mukana ollakseen hyödyllisiä kehittäjille.

Kaikki kolme työkalua pyrkivät tukemaan EcmaScriptin uusinta viimeisteltyä
versiota. Lisäksi Flow tarjoaa tyyppitarkastusta joillekkin kokeellisille
ominaisuuksille joiden EcmaScript-määrittely ei vielä ole täysin valmis mutta
jotka luultavasti tullaan lisäämään myöhemmin. Esimerkiksi
\textit{optional chaining} \cite{Optional_Chaining_proposal} on vielä
suunnitteluvaiheessa oleva kielen ominaisuus, mutta Flow tarjoaa jo
staattisen tyyppitarkastuksen sille. Uusien ominaisuuksien aikaisessa
käyttöönotossa on JavaScriptin kehityksen kannalta se hyvä puoli, että
kehittäjäyhteisö pääsee kokeilemaan ja antamaan palautetta ennen kuin ominaisuuden
määrittely on lyöty lukkoon. TypeScript puolestaan pyrkii vastedes implementoimaan
ainoastaan valmiita ominaisuuksia, sillä keskeneräisen ominaisuuden yksityiskohdat
tulevat suurella todennäköisyydellä muuttumaan useaan otteeseen suunnitteluvaiheen
aikana ja sitä käyttäneet kehittäjät voivat myöhemmin joutua
\textit{refaktoroimaan} koodiaan.

\section{Tyyppien automaattinen ja vaiheittainen tyypittäminen}

Todo

\section{Luotettavuus, täydellisyys ja käytännöllisyys}

\begin{figure}
\includegraphics[width=\textwidth]{images/soundness_completeness2.pdf}
\caption{Tyyppijärjestelmän luotettavuus ja täydellisyys}
\end{figure}

Tyyppijärjestelmän luotettavuus (soundness) kuvaa sitä, kuinka suuren osan
mahdollisista ohjelmointivirheistä se estää. Täysin luotettava (sound)
tyyppijärjestelmä estää kaikki sellaiset virheet jotka sen on tarkoitus
estää \cite{CSE_ProgrammingLanguages}. Täydellisyys (completeness)
puolestaan kertoo salliiko tyyppijärjestelmä kielen sellaiset ominaisuudet
jotka eivät olisi ajonaikana tyyppivirheitä \cite{TypesAndProgrammingLanguages, CSE_ProgrammingLanguages}.

Jotta JavaScriptiä analysoiva tyyppijärjestelmä olisi luotettava, sen on
annettava virhe esimerkiksi seuraavasta ohjelmasta:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Virheellinen JavaScript-ohjelma: Lisätyllä tuotteella ei ole nimeä.}]
function osta(ostos) {
  lisaaTuote({
    nimi: ostos.nimi,
    hinta: ostos.hinta
  });
}

osta({ nimi: 'juusto', hinta: 5 });
osta({ hinta: 5 });
\end{lstlisting}
\label{fig:soundness_test}
\end{minipage}

Toisaalta jotta JavaScriptiä analysoiva tyyppijärjestelmä olisi täydellinen,
sen on sallittava tämä korjattu versio ylläolevasta ohjelmasta:

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Toimiva JavaScript-ohjelma: Virheelliseltä kutsulta on suojauduttu tarkistuksella.}]
function osta(ostos) {
  if (typeof ostos.nimi === 'string') {
    lisaaTuote({
      nimi: ostos.nimi,
      hinta: ostos.hinta
    });
  }
}

osta({ nimi: 'juusto', hinta: 5 });
osta({ hinta: 5 });
\end{lstlisting}
\label{fig:completeness_test}
\end{minipage}

Esimerkit \ref{fig:soundness_test} ja \ref{fig:completeness_test} toimivat
odotetulla tavalla Flow:ssa. TypeScript vaatii eksplisiittisen tyyppiannotaation
osta-funktiolle, mutta toimii muuten samalla tavalla. Flow, TypeScript ja
Closure eivät kuitenkaan ole täydellisiä tai kokonaan luotettavia.
Monimutkaisemmissa tilanteissa virheitä saattaa jäädä nappaamatta tai toimiva
ohjelma voidaan merkata virheelliseksi. JavaScriptiä käännöskohteena käyttävät
mutta muuten sen syntaksista ja semantiikasta eroavat uudet kielet,
kuten Dart ja Elm, on voitu kehittää toivotunlaiseksi ilman painetta olla
yhteensopiva vanhan koodin kanssa.

TypeScript ja Flow on sen sijaan kehitetty lisäämään staattinen tyypitys
olemassa olevaan kieleen, JavaScriptiin, siten että nykyisellään käytössä
olevat kirjastot ja koodikäytännöt pystytään tyyppitarkastamaan ilman että
niiden arkkitehtuuria tarvitsee merkittävästi muuttaa tyyppiturvallisuuden
saavuttamiskesi.

TypeScript on strukturaalisesti tyypitetty, minkä vuoksi seuraava koodi kääntyy
ilman tyyppivirheitä.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Loogisen virheen sisältävä, mutta ilman virheitä kääntyvä TypeScript-ohjelma.}]
class Ihminen {
    constructor(public nimi: string){}
}

class Elain {
    constructor(public nimi: string){}
}

function varaaAikaElainlaakariin(omistaja: Ihminen, lemmikki: Elain)
{
  ...
}

varaaAikaElainlaakariin(new Elain("Musti"), new Ihminen("Jaakko"));
\end{lstlisting}
\label{fig:structural_typing_error}
\end{minipage}

TypeScript-kääntäjä sallii esimerkin \ref{fig:structural_typing_error} koodin
vaikka arugmentit "omistaja" ja "lemmikki" ovat väärin päin, sillä
molempien luokkien rakenne on sama; molemmissa on pelkkä tekstimuotoinen
ominaisuus "nimi". Flow:ssa sama virhe ei menisi läpi. Siinä luokkainstanssit
on tyypitetty nominaalisesti, mikä auttaa tässä esimerkissä mutta aiehuttaa ongelmia
muissa tilanteissa. Projekti saattaa esimerkiksi sisältää kaksi versiota samasta
kirjastosta jonkin toisen kirjaston kautta, mikä voi aiheuttaa yhteensopimusongelmia
kun käytännössä saman luokan tyyppejä ei lueta keskenään yhteensopiviksi. 